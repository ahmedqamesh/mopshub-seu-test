//
// Module I2C_HC_TestMaster_lib.master_fsm.fsm
//
// Created:
//          by - lehmann.edagrp (chipdev2.physik.uni-wuppertal.de)
//          at - 08:25:20 07/21/16
//
// Generated by Mentor Graphics' HDL Designer(TM) 2015.1b (Build 4)
//
`resetall
`timescale 1ns/10ps
module master_fsm( 
   // Port Declarations
   input   wire           RSTn, 
   input   wire    [6:0]  addr, 
   input   wire           clk, 
   input   wire           counter_ready, 
   input   wire           rx_allbytes, 
   input   wire           rx_start, 
   input   wire           scl, 
   input   wire           sda_in, 
   input   wire           tx_allbytes, 
   input   wire    [7:0]  tx_data, 
   input   wire           tx_start, 
   input   wire           valid_syndrom, 
   output  reg            clear_rx_start, 
   output  reg            clear_syndrom, 
   output  reg            clear_tx_start, 
   output  reg     [7:0]  data, 
   output  reg            done, 
   output  reg            load_ack, 
   output  reg            load_counter, 
   output  reg            load_data, 
   output  reg            load_nack, 
   output  reg            load_start, 
   output  reg            load_stop, 
   output  reg            rx_bytecnt, 
   output  reg            rx_bytecnt_clear, 
   output  reg            rx_shift_enable, 
   output  reg            tx_bytecnt, 
   output  reg            tx_bytecnt_clear
);


// Internal Declarations


// Module Declarations

// State encoding
parameter 
          IDLE            = 5'd0,
          WAIT_START      = 5'd1,
          START           = 5'd2,
          ADDRW_LD        = 5'd3,
          ADDRW_TX        = 5'd4,
          ADDRW_WAIT_ACK  = 5'd5,
          ADDRW_CHECK_ACK = 5'd6,
          STOP            = 5'd7,
          LOAD_STOP       = 5'd8,
          TX_LD           = 5'd9,
          ADDRR_LD        = 5'd10,
          ADDRR_TX        = 5'd11,
          ADDRR_WAIT_ACK  = 5'd12,
          ADDRR_CHECK_ACK = 5'd13,
          TX              = 5'd14,
          TX_WAIT_ACK     = 5'd15,
          TX_CHECK_ACK    = 5'd16,
          RX_START        = 5'd17,
          RX              = 5'd18,
          RX_SENDACK      = 5'd19,
          RX_PREP_ACK     = 5'd20,
          RX_SENDNACK     = 5'd21,
          LOAD_START      = 5'd22;

reg [4:0] current_state, next_state;

//-----------------------------------------------------------------
// Next State Block for machine csm
//-----------------------------------------------------------------
always @(
   counter_ready or 
   current_state or 
   rx_allbytes or 
   rx_start or 
   scl or 
   sda_in or 
   tx_allbytes or 
   tx_start or 
   valid_syndrom
)
begin : next_state_block_proc
   case (current_state) 
      IDLE: begin
         if (tx_start || 
             rx_start)
            next_state = WAIT_START;
         else
            next_state = IDLE;
      end
      WAIT_START: begin
         if (~scl)
            next_state = LOAD_START;
         else
            next_state = WAIT_START;
      end
      START: begin
         if (tx_start)
            next_state = ADDRW_LD;
         else if (rx_start)
            next_state = ADDRR_LD;
         else
            next_state = START;
      end
      ADDRW_LD: begin
         next_state = ADDRW_TX;
      end
      ADDRW_TX: begin
         if (counter_ready)
            next_state = ADDRW_WAIT_ACK;
         else
            next_state = ADDRW_TX;
      end
      ADDRW_WAIT_ACK: begin
         next_state = ADDRW_CHECK_ACK;
      end
      ADDRW_CHECK_ACK: begin
         if (~sda_in)
            next_state = TX_LD;
         else
            next_state = LOAD_STOP;
      end
      STOP: begin
         next_state = IDLE;
      end
      LOAD_STOP: begin
         next_state = STOP;
      end
      TX_LD: begin
         next_state = TX;
      end
      ADDRR_LD: begin
         next_state = ADDRR_TX;
      end
      ADDRR_TX: begin
         if (counter_ready)
            next_state = ADDRR_WAIT_ACK;
         else
            next_state = ADDRR_TX;
      end
      ADDRR_WAIT_ACK: begin
         next_state = ADDRR_CHECK_ACK;
      end
      ADDRR_CHECK_ACK: begin
         if (~sda_in)
            next_state = RX_START;
         else
            next_state = LOAD_STOP;
      end
      TX: begin
         if (counter_ready)
            next_state = TX_WAIT_ACK;
         else
            next_state = TX;
      end
      TX_WAIT_ACK: begin
         next_state = TX_CHECK_ACK;
      end
      TX_CHECK_ACK: begin
         if (~sda_in &&
             ~tx_allbytes)
            next_state = TX_LD;
         else if (tx_allbytes &&
                  rx_start &&
                  (~sda_in))
            next_state = WAIT_START;
         else
            next_state = LOAD_STOP;
      end
      RX_START: begin
         next_state = RX;
      end
      RX: begin
         if (counter_ready)
            next_state = RX_PREP_ACK;
         else
            next_state = RX;
      end
      RX_SENDACK: begin
         if (scl)
            next_state = RX_START;
         else
            next_state = RX_SENDACK;
      end
      RX_PREP_ACK: begin
         if (valid_syndrom &&
             ~rx_allbytes)
            next_state = RX_SENDACK;
         else
            next_state = RX_SENDNACK;
      end
      RX_SENDNACK: begin
         next_state = LOAD_STOP;
      end
      LOAD_START: begin
         next_state = START;
      end
      default: 
         next_state = IDLE;
   endcase
end // Next State Block

//-----------------------------------------------------------------
// Output Block for machine csm
//-----------------------------------------------------------------
always @(
   addr or 
   current_state or 
   rx_allbytes or 
   rx_start or 
   sda_in or 
   tx_data or 
   tx_start or 
   valid_syndrom
)
begin : output_block_proc
   // Default Assignment
   clear_rx_start = 0;
   clear_syndrom = 1;
   clear_tx_start = 0;
   data = 8'hFF;
   done = 0;
   load_ack = 0;
   load_counter = 1;
   load_data = 0;
   load_nack = 0;
   load_start = 0;
   load_stop = 0;
   rx_bytecnt = 0;
   rx_bytecnt_clear = 0;
   rx_shift_enable = 0;
   tx_bytecnt = 0;
   tx_bytecnt_clear = 0;

   // Combined Actions
   case (current_state) 
      IDLE: begin
         done = 1;
         if (tx_start || rx_start)
         begin
           tx_bytecnt_clear = 1;
           rx_bytecnt_clear = 1;
         end
      end
      ADDRW_LD: begin
         load_data = 1;
         data = {addr,1'b0};
         clear_tx_start = 1;
         tx_bytecnt_clear = 1;
      end
      ADDRW_TX: begin
         load_counter = 0;
      end
      LOAD_STOP: begin
         load_stop = 1;
         clear_rx_start = 1;
         clear_tx_start = 1;
      end
      TX_LD: begin
         data = tx_data;
         load_data = 1;
      end
      ADDRR_LD: begin
         load_data = 1;
         data = {addr,1'b1};
         clear_rx_start = 1;
         rx_bytecnt_clear = 1;
      end
      ADDRR_TX: begin
         load_counter = 0;
      end
      TX: begin
         load_counter = 0;
      end
      TX_CHECK_ACK: begin
         if (~sda_in)
           tx_bytecnt = 1;
      end
      RX_START: begin
         rx_shift_enable = 1;
         clear_syndrom = 0;
      end
      RX: begin
         rx_shift_enable = 1;
         load_counter = 0;
         clear_syndrom = 0;
      end
      RX_PREP_ACK: begin
         if (valid_syndrom)
           rx_bytecnt = 1;
         if (valid_syndrom &&
             ~rx_allbytes)
            load_ack = 1;
         else
            load_nack = 1;
      end
      LOAD_START: begin
         load_start = 1;
      end
   endcase
end // Output Block

//-----------------------------------------------------------------
// Clocked Block for machine csm
//-----------------------------------------------------------------
always @(
   posedge clk or 
   negedge RSTn
) 
begin : clocked_block_proc
   if (!RSTn) begin
      current_state <= IDLE;
   end
   else 
   begin
      current_state <= next_state;
   end
end // Clocked Block

endmodule // master_fsm
