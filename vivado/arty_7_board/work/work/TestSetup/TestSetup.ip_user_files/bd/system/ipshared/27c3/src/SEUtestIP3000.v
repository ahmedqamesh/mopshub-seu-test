//
// Module SEUtestIP_lib.seutest_ip_top.struct
//
// Created:
//          by - caspar.caspar (chips.pleiades.uni-wuppertal.de)
//          at - 10:08:49 08/08/18
//
// Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
//

`resetall
`timescale 1ns/10ps
module SEUtestIP3000( 
   // Port Declarations
   input   wire            S_AXI_ACLK, 
   input   wire    [9:0]   S_AXI_ARADDR, 
   input   wire            S_AXI_ARESETN, 
   input   wire            S_AXI_ARVALID, 
   input   wire    [9:0]   S_AXI_AWADDR, 
   input   wire            S_AXI_AWVALID, 
   input   wire            S_AXI_BREADY, 
   input   wire            S_AXI_RREADY, 
   input   wire    [31:0]  S_AXI_WDATA, 
   input   wire    [3:0]   S_AXI_WSTRB, 
   input   wire            S_AXI_WVALID, 
   input   wire            TMR, 
   input   wire            simple, 
   output  wire            S_AXI_ARREADY, 
   output  wire            S_AXI_AWREADY, 
   output  wire    [1:0]   S_AXI_BRESP, 
   output  wire            S_AXI_BVALID, 
   output  wire    [31:0]  S_AXI_RDATA, 
   output  wire    [1:0]   S_AXI_RRESP, 
   output  wire            S_AXI_RVALID, 
   output  wire            S_AXI_WREADY, 
   output  wire            data, 
   output  wire            mode, 
   output  wire            shift_clk
);


// Internal Declarations



// Local declarations

// Internal signal declarations
wire         clear;
wire         clear_counters;
wire  [2:0]  cntbits;
wire  [8:0]  cntbytes;
wire  [7:0]  data_out;
wire  [7:0]  data_out1;
wire  [31:0] data_out_axi;
wire  [63:0] data_simple_axi;
wire  [63:0] data_tmr_axi;
wire  [31:0] dividor;
wire				 shift_clk_en;
wire         golden;
wire         golden_synch;
wire         idle;
wire         load;
wire         pre_pulse;
wire         rst;
wire         run;
wire  [31:0] shift_data_out;
wire         shift_pulse;
wire         shift_pulse_n;
wire         simple_fifo_almost_full;
wire         simple_fifo_empty;
wire         simple_fifo_full;
wire         simple_fifo_reset;
wire  [15:0] simple_high;
wire  [15:0] simple_low;
wire  [15:0] simple_ones;
wire         simple_read;
wire         simple_synch;
wire  [15:0] simple_zeros;
wire         store;
wire         tmr_fifo_almost_full;
wire         tmr_fifo_empty;
wire         tmr_fifo_full;
wire         tmr_fifo_reset;
wire  [15:0] tmr_high;
wire  [15:0] tmr_low;
wire  [15:0] tmr_ones;
wire         tmr_read;
wire         tmr_synch;
wire  [15:0] tmr_zeros;
wire         write;
wire         write_fifo_full;
wire         mode_n;
wire         shift_clk_n;
wire         data_n;

// invert signals to match level shifter on testbaord
assign mode = ~mode_n;
assign shift_clk = ~shift_clk_n;
assign data = ~data_n;
assign TMR_n = ~TMR;
assign simple_n = ~simple;


// Instances 
axi_control_unit axi_control_unit_inst( 
   .S_AXI_ACLK              (S_AXI_ACLK), 
   .S_AXI_ARESETN           (S_AXI_ARESETN), 
   .S_AXI_AWADDR            (S_AXI_AWADDR), 
   .S_AXI_AWVALID           (S_AXI_AWVALID), 
   .S_AXI_AWREADY           (S_AXI_AWREADY), 
   .S_AXI_WDATA             (S_AXI_WDATA), 
   .S_AXI_WSTRB             (S_AXI_WSTRB), 
   .S_AXI_WVALID            (S_AXI_WVALID), 
   .S_AXI_WREADY            (S_AXI_WREADY), 
   .S_AXI_BRESP             (S_AXI_BRESP), 
   .S_AXI_BVALID            (S_AXI_BVALID), 
   .S_AXI_BREADY            (S_AXI_BREADY), 
   .S_AXI_ARADDR            (S_AXI_ARADDR), 
   .S_AXI_ARVALID           (S_AXI_ARVALID), 
   .S_AXI_ARREADY           (S_AXI_ARREADY), 
   .S_AXI_RDATA             (S_AXI_RDATA), 
   .S_AXI_RRESP             (S_AXI_RRESP), 
   .S_AXI_RVALID            (S_AXI_RVALID), 
   .S_AXI_RREADY            (S_AXI_RREADY), 
   .dividor                 (dividor), 
   .shift_clk_en            (shift_clk_en), 
   .write                   (write), 
   .data_out                (data_out_axi), 
   .run                     (run), 
   .idle                    (idle), 
   .write_fifo_full         (write_fifo_full), 
   .simple_fifo_full        (simple_fifo_full), 
   .simple_fifo_almost_full (simple_fifo_almost_full), 
   .simple_fifo_empty       (simple_fifo_empty), 
   .simple_read             (simple_read), 
   .simple_data             (data_simple_axi), 
   .tmr_fifo_full           (tmr_fifo_full), 
   .tmr_fifo_almost_full    (tmr_fifo_almost_full), 
   .tmr_fifo_empty          (tmr_fifo_empty), 
   .tmr_read                (tmr_read), 
   .tmr_data                (data_tmr_axi), 
   .simple_ones             (simple_ones), 
   .simple_zeros            (simple_zeros), 
   .simple_high             (simple_high), 
   .simple_low              (simple_low), 
   .tmr_ones                (tmr_ones), 
   .tmr_zeros               (tmr_zeros), 
   .tmr_high                (tmr_high), 
   .tmr_low                 (tmr_low), 
   .clear_seucounter        (clear_counters),
   .clear_fifo_simple       (clear_fifo_simple),
   .clear_fifo_tmr          (clear_fifo_tmr)
); 

clock_divider clock_divider_inst( 
   .clk           (S_AXI_ACLK), 
   .rst_n         (S_AXI_ARESETN), 
   .dividor       (dividor), 
   .shift_clk_en  (shift_clk_en), 
   .shift_clk     (shift_clk_n), 
   .shift_pulse   (shift_pulse),
   .shift_pulse_n (shift_pulse_n), 
   .pre_pulse     (pre_pulse)
); 

compare_counter simple_compare_counter_inst( 
   .clk       (S_AXI_ACLK), 
   .rst_n     (S_AXI_ARESETN), 
   .clear     (clear_counters), 
   .pulse     (shift_pulse), 
   .mode      (mode_n), 
   .golden_in (golden_synch), 
   .dut_in    (simple_synch), 
   .cnt_ones  (simple_ones), 
   .cnt_zeros (simple_zeros), 
   .cnt_high  (simple_high), 
   .cnt_low   (simple_low)
); 

compare_counter tmr_compare_counter_inst( 
   .clk       (S_AXI_ACLK), 
   .rst_n     (S_AXI_ARESETN), 
   .clear     (clear_counters), 
   .pulse     (shift_pulse), 
   .mode      (mode_n), 
   .golden_in (golden_synch), 
   .dut_in    (tmr_synch), 
   .cnt_ones  (tmr_ones), 
   .cnt_zeros (tmr_zeros), 
   .cnt_high  (tmr_high), 
   .cnt_low   (tmr_low)
); 

control control_fsm( 
   .clk           (S_AXI_ACLK), 
   .cntbytes      (cntbytes),
   .cntbits       (cntbits), 
   .pre_pulse     (pre_pulse), 
   .pulse         (shift_pulse), 
   .rst_n         (S_AXI_ARESETN), 
   .run           (run), 
   .clear         (clear), 
   .idle          (idle), 
   .load          (load), 
   .mode_internal (mode_n), 
   .store         (store)
); 

counter bitcounter_inst( 
   .clk   (S_AXI_ACLK), 
   .rst_n (S_AXI_ARESETN), 
   .pulse (shift_pulse), 
   .clear (clear), 
   .cnt   (cntbits)
); 

bytecounter bytecounter_inst( 
   .clk   (S_AXI_ACLK), 
   .rst_n (S_AXI_ARESETN), 
   .pulse (store), 
   .clear (clear), 
   .cnt   (cntbytes)
); 

assign simple_fifo_reset = rst | clear_fifo_simple;
fifo_in fifo_in_simple_inst( 
   .clk         (S_AXI_ACLK), 
   .rst         (simple_fifo_reset), 
   .din         (data_out), 
   .wr_en       (store), 
   .rd_en       (simple_read), 
   .dout        (data_simple_axi), 
   .full        (simple_fifo_full), 
   .almost_full (simple_fifo_almost_full), 
   .empty       (simple_fifo_empty)
); 

assign tmr_fifo_reset = rst | clear_fifo_tmr;
fifo_in fifo_in_tmr_inst( 
   .clk         (S_AXI_ACLK), 
   .rst         (tmr_fifo_reset), 
   .din         (data_out1), 
   .wr_en       (store), 
   .rd_en       (tmr_read), 
   .dout        (data_tmr_axi), 
   .full        (tmr_fifo_full), 
   .almost_full (tmr_fifo_almost_full), 
   .empty       (tmr_fifo_empty)
); 

fifo_out fifo_out_inst( 
   .clk          (S_AXI_ACLK), 
   .rst_n        (S_AXI_ARESETN), 
   .data_out_axi (data_out_axi), 
   .write        (write), 
   .data_out     (shift_data_out), 
   .load         (load), 
   .full         (write_fifo_full)
); 

golden_shift golden_shift_inst( 
   .clk   (S_AXI_ACLK), 
   .rst_n (S_AXI_ARESETN),
   .pulse (shift_pulse_n), 
   .mode  (mode_n), 
   .din   (data_n), 
   .dout  (golden)
); 

shift_in simple_shiftin_inst( 
   .clk      (S_AXI_ACLK), 
   .rst_n    (S_AXI_ARESETN), 
   .pulse    (shift_pulse), 
   .mode     (mode_n), 
   .data_out (data_out), 
   .data_in  (simple_synch)
); 

shift_in tmr_shiftin_inst( 
   .clk      (S_AXI_ACLK), 
   .rst_n    (S_AXI_ARESETN), 
   .pulse    (shift_pulse), 
   .mode     (mode_n), 
   .data_out (data_out1), 
   .data_in  (tmr_synch)
); 

shift_out shift_out_inst( 
   .clk      (S_AXI_ACLK), 
   .rst_n    (S_AXI_ARESETN), 
   .pulse    (shift_pulse), 
   .mode     (mode_n), 
   .load     (load), 
   .data_in  (shift_data_out), 
   .data_out (data_n)
); 

synch_in simple_synchin_inst( 
   .clk   (S_AXI_ACLK), 
   .rst_n (S_AXI_ARESETN), 
   .din   (simple_n), 
   .dout  (simple_synch)
); 

synch_in simple_synchin_inst1( 
   .clk   (S_AXI_ACLK), 
   .rst_n (S_AXI_ARESETN), 
   .din   (golden), 
   .dout  (golden_synch)
); 

synch_in tmr_synchin_inst( 
   .clk   (S_AXI_ACLK), 
   .rst_n (S_AXI_ARESETN), 
   .din   (TMR_n), 
   .dout  (tmr_synch)
); 

// HDL Embedded Text Block 1 RST
// non-inverted reset
assign rst = ~S_AXI_ARESETN;

endmodule // seutest_ip_top

